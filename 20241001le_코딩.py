# -*- coding: utf-8 -*-
"""20241001LE_코딩.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nFiGiI7Y_nJGFqM0Dcu-JJMUrTLBMtgp
"""

#데이터셋 내부 폴더 구조 확인
import os

# 폴더 구조를 출력하는 함수 (각 폴더에서 파일은 최대 5개만 출력)
def print_directory_structure(folder_path, max_files=5):
    for root, dirs, files in os.walk(folder_path):
        level = root.replace(folder_path, '').count(os.sep)
        indent = ' ' * 4 * level
        print(f"{indent}{os.path.basename(root)}/")
        sub_indent = ' ' * 4 * (level + 1)

        # 파일이 많을 경우 최대 max_files개만 출력
        for file in files[:max_files]:
            print(f"{sub_indent}{file}")

        # 파일이 더 있으면 생략 표시
        if len(files) > max_files:
            print(f"{sub_indent}...({len(files) - max_files} more files)")

# 경로 설정
dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_ori'

# 폴더 구조 출력
print_directory_structure(dataset_path)

#.JPG.json 파일 .json 으로 변경
import os

# 경로 설정
dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_ori'

# 파일명을 수정하는 함수
def rename_json_files(folder_path):
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            # 파일이 '.JPG.json', '.JPEG.json', '.jpeg.json', '.jpg.json'으로 끝나는지 확인
            if (file.endswith('.JPG.json') or file.endswith('.JPEG.json') or
                file.endswith('.jpeg.json') or file.endswith('.jpg.json')):
                # 새로운 파일명 생성
                new_file_name = (file.replace('.JPG.json', '.json')
                                     .replace('.JPEG.json', '.json')
                                     .replace('.jpeg.json', '.json')
                                     .replace('.jpg.json', '.json'))

                # 경로 생성
                old_file_path = os.path.join(root, file)
                new_file_path = os.path.join(root, new_file_name)

                # 파일 이름 변경
                os.rename(old_file_path, new_file_path)
                print(f"Renamed: {old_file_path} -> {new_file_path}")

# 파일명 변경 실행
rename_json_files(dataset_path)

#폴더내부 jpeg 등 모든 그림확장자 jpg 로 변경
import os

def change_image_extension(folder_path, original_exts=['.jpeg', '.png'], target_ext='.jpg'):
    """
    모든 이미지 파일의 확장자를 target_ext로 변경.
    - folder_path: 최상위 폴더 경로
    - original_exts: 변경할 확장자 목록
    - target_ext: 변경 후 사용할 확장자
    """
    for root, _, files in os.walk(folder_path):
        for file in files:
            # 파일의 확장자 확인
            file_ext = os.path.splitext(file)[-1].lower()
            # 변경할 확장자 목록에 해당되는 경우
            if file_ext in original_exts:
                old_file_path = os.path.join(root, file)
                new_file_name = os.path.splitext(file)[0] + target_ext
                new_file_path = os.path.join(root, new_file_name)

                # 파일명 변경
                os.rename(old_file_path, new_file_path)
                print(f"Renamed: {old_file_path} -> {new_file_path}")

# 경로 설정
dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_ori'

# 확장자 변경 실행
change_image_extension(dataset_path, original_exts=['.jpeg', '.png'], target_ext='.jpg')

#하위 폴더에 각각 폴더내부에 .jpg 와 .json 파일 중 교집합으로 매치되지 않는 파일 숫자 나열
import os

def count_unmatched_files(folder_path):
    """
    각 하위 폴더에 있는 .jpg와 .json 파일의 교집합에 매치되지 않는 파일 숫자를 나열.
    """
    for root, _, files in os.walk(folder_path):
        # 해당 폴더에 있는 .jpg와 .json 파일 리스트 생성
        jpg_files = set([os.path.splitext(file)[0] for file in files if file.lower().endswith('.jpg')])
        json_files = set([os.path.splitext(file)[0] for file in files if file.lower().endswith('.json')])

        # 교집합에 매치되지 않는 파일 계산
        unmatched_jpg = jpg_files - json_files
        unmatched_json = json_files - jpg_files

        # 매치되지 않는 파일 수 출력
        if unmatched_jpg or unmatched_json:
            print(f"Directory: {root}")
            print(f"Unmatched .jpg files: {len(unmatched_jpg)}")
            print(f"Unmatched .json files: {len(unmatched_json)}\n")

# 경로 설정
dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_ori'

# 함수 실행
count_unmatched_files(dataset_path)

#매치되지 않는 빠진 파일 삭제
import os

def remove_unmatched_files(folder_path):
    """
    각 하위 폴더에서 .jpg와 .json 파일의 교집합에 매치되지 않는 파일을 삭제.
    """
    for root, _, files in os.walk(folder_path):
        # 해당 폴더에 있는 .jpg와 .json 파일 리스트 생성
        jpg_files = set([os.path.splitext(file)[0] for file in files if file.lower().endswith('.jpg')])
        json_files = set([os.path.splitext(file)[0] for file in files if file.lower().endswith('.json')])

        # 교집합에 매치되지 않는 파일 확인
        unmatched_jpg = jpg_files - json_files
        unmatched_json = json_files - jpg_files

        # 매치되지 않는 .jpg 파일 삭제
        for unmatched in unmatched_jpg:
            jpg_file_path = os.path.join(root, unmatched + '.jpg')
            if os.path.exists(jpg_file_path):
                os.remove(jpg_file_path)
                print(f"Deleted: {jpg_file_path}")

        # 매치되지 않는 .json 파일 삭제
        for unmatched in unmatched_json:
            json_file_path = os.path.join(root, unmatched + '.json')
            if os.path.exists(json_file_path):
                os.remove(json_file_path)
                print(f"Deleted: {json_file_path}")

# 경로 설정
dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_ori'

# 함수 실행
remove_unmatched_files(dataset_path)

#label 과 image 분리(수동)

#재확인
#데이터셋 내부 폴더 구조 확인
import os

# 폴더 구조를 출력하는 함수 (각 폴더에서 파일은 최대 5개만 출력)
def print_directory_structure(folder_path, max_files=5):
    for root, dirs, files in os.walk(folder_path):
        level = root.replace(folder_path, '').count(os.sep)
        indent = ' ' * 4 * level
        print(f"{indent}{os.path.basename(root)}/")
        sub_indent = ' ' * 4 * (level + 1)

        # 파일이 많을 경우 최대 max_files개만 출력
        for file in files[:max_files]:
            print(f"{sub_indent}{file}")

        # 파일이 더 있으면 생략 표시
        if len(files) > max_files:
            print(f"{sub_indent}...({len(files) - max_files} more files)")

# 경로 설정
dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_ori'

# 폴더 구조 출력
print_directory_structure(dataset_path)

#리사이즈, 폴더 새로 만들기, json은 폴더 구조 그대로 복사, 하단 작업부터는 sized 로 작업 시작
import os
from PIL import Image
import shutil

# 원본 데이터셋 경로
original_dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_ori'
# 리사이즈된 데이터를 저장할 경로
resized_dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_sized'

# 너비를 640으로 설정
target_width = 640

# 비율을 유지하면서 너비를 640으로 리사이즈하는 함수
def resize_image_to_width(img, target_width):
    # 원본 이미지 크기
    width, height = img.size
    # 비율에 맞춰 높이 계산
    new_height = int((target_width / width) * height)
    # 이미지 리사이즈
    return img.resize((target_width, new_height))

# 기존 폴더 구조를 유지하면서 이미지를 리사이즈하고 저장
def resize_and_save_images(original_folder, resized_folder, target_width):
    # 모든 폴더를 탐색
    for root, dirs, files in os.walk(original_folder):
        # 리사이징된 파일을 저장할 동일한 경로 생성
        relative_path = os.path.relpath(root, original_folder)
        new_folder = os.path.join(resized_folder, relative_path)
        os.makedirs(new_folder, exist_ok=True)

        for file in files:
            # 이미지 파일만 처리
            if file.lower().endswith(('.jpg', '.jpeg', '.png')):
                original_file_path = os.path.join(root, file)
                new_file_path = os.path.join(new_folder, file)

                # 이미지 열기 및 리사이즈
                try:
                    with Image.open(original_file_path) as img:
                        # 이미지 비율을 유지하며 너비를 640으로 리사이즈
                        resized_img = resize_image_to_width(img, target_width)
                        # 리사이즈된 이미지 저장 (format='JPEG' 지정)
                        resized_img.save(new_file_path, format='JPEG')
                    print(f"이미지 리사이즈 완료: {new_file_path}")
                except Exception as e:
                    print(f"이미지 처리 실패: {original_file_path} -> {e}")

            # .json 파일만 복사
            elif file.lower().endswith('.json'):
                try:
                    original_json_path = os.path.join(root, file)
                    new_json_path = os.path.join(new_folder, file)
                    shutil.copy(original_json_path, new_json_path)
                    print(f"JSON 파일 복사 완료: {new_json_path}")
                except Exception as e:
                    print(f"JSON 파일 복사 실패: {original_json_path} -> {e}")

# 함수 실행
resize_and_save_images(original_dataset_path, resized_dataset_path, target_width)

#Json ->txt 확장자 라벨로 변경
import os
import json

# 경로 설정
dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_sized'

# JSON 파일을 YOLO 형식의 TXT 파일로 변환하는 함수
def convert_json_to_yolo(json_file, txt_file, class_id):
    try:
        with open(json_file, 'r', encoding='utf-8') as f:
            data = json.load(f)

        # 이미지 크기 가져오기
        img_width = data['description'].get('width', 1)  # 기본값 1로 설정하여 0으로 나누는 오류 방지
        img_height = data['description'].get('height', 1)

        yolo_lines = []

        # annotations 항목이 있고, points 정보가 있을 때만 처리
        if 'annotations' in data and 'points' in data['annotations']:
            for annotation in data['annotations']['points']:
                # 바운딩 박스 좌표를 상대 좌표로 변환
                xtl = annotation['xtl'] / img_width  # x 좌측 상단
                ytl = annotation['ytl'] / img_height # y 좌측 상단
                xbr = annotation['xbr'] / img_width  # x 우측 하단
                ybr = annotation['ybr'] / img_height # y 우측 하단

                # YOLO 형식으로 바운딩 박스 중앙 좌표와 너비, 높이 계산
                x_center = (xtl + xbr) / 2
                y_center = (ytl + ybr) / 2
                width = xbr - xtl
                height = ybr - ytl

                # YOLO 형식으로 저장할 라인 생성
                yolo_lines.append(f"{class_id} {x_center:.6f} {y_center:.6f} {width:.6f} {height:.6f}\n")

        # YOLO 형식의 데이터를 .txt 파일로 저장
        with open(txt_file, 'w') as f:
            f.writelines(yolo_lines)
        print(f"YOLO 파일 생성: {txt_file}")
        return True  # 성공 시 True 반환

    except Exception as e:
        print(f"YOLO 변환 실패: {json_file} -> {e}")
        return False  # 실패 시 False 반환

# 모든 하위 폴더에서 .json 파일을 찾아서 .txt 파일로 변환하는 함수
def process_all_json_files(dataset_folder):
    failed_count = 0  # 실패한 파일 개수 카운트
    for root, dirs, files in os.walk(dataset_folder):
        # 최하단(leaf) 폴더에서만 변환 작업 수행
        if not dirs:  # 현재 폴더에 하위 폴더가 없으면 (최하단 폴더)
            for file in files:
                if file.endswith('.json'):
                    json_file_path = os.path.join(root, file)
                    txt_file_path = os.path.join(root, file.replace('.json', '.txt'))

                    # 상위 폴더 이름을 기준으로 클래스 ID 설정
                    parent_folder_name = os.path.basename(root)
                    if parent_folder_name == 'disease':
                        class_id = 1  # 질병
                    elif parent_folder_name == 'normal':
                        class_id = 0  # 정상
                    else:
                        continue  # 'disease'나 'normal' 폴더가 아니면 건너뜀

                    # YOLO 형식으로 변환 시도
                    if not convert_json_to_yolo(json_file_path, txt_file_path, class_id):
                        failed_count += 1  # 실패 시 카운트 증가

    print(f"\n총 변환 실패한 파일 개수: {failed_count}")

# 함수 실행
process_all_json_files(dataset_path)

#Json ->txt 확장자 라벨 변경 시각화 및 점검 (20개씩)
import os
import random
import matplotlib.pyplot as plt
from PIL import Image
import matplotlib.patches as patches

# 경로 설정
dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_sized'

# YOLO 형식의 바운딩 박스를 이미지에 시각화하는 함수
def display_image_with_yolo_bbox(image_path, txt_file, img_width, img_height):
    # 이미지 열기
    img = Image.open(image_path)

    # 텍스트 파일 열기 (YOLO 형식)
    with open(txt_file, 'r') as f:
        yolo_data = f.readlines()

    # 바운딩 박스 정보를 가져오기
    fig, ax = plt.subplots(1, figsize=(10, 10))  # 출력 크기 조절
    ax.imshow(img)

    for line in yolo_data:
        # YOLO 형식: <class_id> <x_center> <y_center> <width> <height>
        class_id, x_center, y_center, width, height = map(float, line.strip().split())

        # 이미지 좌표로 변환
        x_center *= img_width
        y_center *= img_height
        width *= img_width
        height *= img_height

        # 좌상단 좌표 계산
        x_min = x_center - width / 2
        y_min = y_center - height / 2

        # 바운딩 박스 그리기
        rect = patches.Rectangle((x_min, y_min), width, height, linewidth=2, edgecolor='r', facecolor='none')
        ax.add_patch(rect)

    plt.title(f"File: {os.path.basename(image_path)}")
    plt.axis('off')  # 축을 끔
    plt.show()

# 특정 폴더에서 랜덤한 이미지 20개와 해당 YOLO 텍스트 파일 시각화
def display_random_images_with_bboxes(image_folder, label_folder, count=20):
    # 이미지와 텍스트 파일 리스트 생성
    image_files = [f for f in os.listdir(image_folder) if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
    txt_files = [f for f in os.listdir(label_folder) if f.endswith('.txt')]

    # 이미지와 텍스트 파일이 동일한 이름을 가졌는지 확인 후 공통 파일만 선택
    common_files = set([os.path.splitext(f)[0] for f in image_files]).intersection(
        set([os.path.splitext(f)[0] for f in txt_files])
    )

    if common_files:
        # 랜덤하게 선택할 파일들 목록
        selected_files = random.sample(list(common_files), min(count, len(common_files)))
        for file_name in selected_files:
            image_path = os.path.join(image_folder, file_name + '.jpg')  # 이미지 확장자를 맞게 조정
            txt_file_path = os.path.join(label_folder, file_name + '.txt')

            # 이미지 크기 가져오기
            img = Image.open(image_path)
            img_width, img_height = img.size

            # 이미지와 바운딩 박스 시각화
            display_image_with_yolo_bbox(image_path, txt_file_path, img_width, img_height)
    else:
        print(f"'{image_folder}'와 '{label_folder}' 폴더에서 공통 파일을 찾을 수 없습니다.")

# 각 폴더에서 랜덤으로 20개씩 확인
folders = [
    ('images/val/disease', 'labels/val/disease'),
    ('images/train/normal', 'labels/train/normal'),
    ('images/val/normal', 'labels/val/normal'),
    ('images/train/disease', 'labels/train/disease')
]

# 각 폴더에서 랜덤으로 20개씩 확인
for image_subfolder, label_subfolder in folders:
    image_folder = os.path.join(dataset_path, image_subfolder)
    label_folder = os.path.join(dataset_path, label_subfolder)

    print(f"\n폴더: {image_subfolder}")
    display_random_images_with_bboxes(image_folder, label_folder, count=20)

#하위 폴더 모든 json 확장자 삭제
import os

# 경로 설정
dataset_path = r'C:\Users\school\PycharmProjects\Paper5_le\dataset_le_sized'

# 모든 하위 폴더에서 .json 파일 삭제
def delete_all_json_files(folder_path):
    deleted_count = 0  # 삭제된 파일 개수 카운트

    for root, _, files in os.walk(folder_path):
        for file in files:
            if file.endswith('.json'):
                file_path = os.path.join(root, file)

                try:
                    os.remove(file_path)
                    print(f"삭제 완료: {file_path}")
                    deleted_count += 1  # 삭제된 파일 개수 증가
                except Exception as e:
                    print(f"삭제 실패: {file_path} -> {e}")

    print(f"\n총 삭제된 .json 파일 개수: {deleted_count}")

# 함수 실행
delete_all_json_files(dataset_path)

#잘못된 좌표 점검

#train 데이터를 그냥 train 과 val 로 분할 normal 에서 랜덤으로 1000개 추출 disease 에서 랜덤으로 2000개 추출
import os
import random
import shutil

# 원본 데이터셋 경로
dataset_path = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_sized'

# train 및 val 저장 경로
train_base_path = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/train'
val_base_path = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/val'

# 사용할 폴더 (image-train-disease, image-train-normal, label-train-disease, label-train-normal)
image_folders = {
    'disease': os.path.join(dataset_path, 'images', 'train', 'disease'),
    'normal': os.path.join(dataset_path, 'images', 'train', 'normal')
}

label_folders = {
    'disease': os.path.join(dataset_path, 'labels', 'train', 'disease'),
    'normal': os.path.join(dataset_path, 'labels', 'train', 'normal')
}

# 클래스별 사용할 이미지와 라벨 개수 설정
num_samples = {
    'disease': 2000,
    'normal': 1000
}

# train 및 val 폴더 내의 클래스별 폴더 생성
for category in image_folders.keys():
    os.makedirs(os.path.join(train_base_path, 'images', category), exist_ok=True)
    os.makedirs(os.path.join(train_base_path, 'labels', category), exist_ok=True)
    os.makedirs(os.path.join(val_base_path, 'images', category), exist_ok=True)
    os.makedirs(os.path.join(val_base_path, 'labels', category), exist_ok=True)

# 데이터를 분할할 비율 (train: 70%, val: 30%)
train_ratio = 0.7

# 이미지 확장자
image_ext = ['.jpg', '.jpeg', '.png', '.JPG', '.JPEG']

# 파일 이동 함수 (이미지와 라벨을 함께 이동)
def move_files(image_list, label_list, dest_image_folder, dest_label_folder):
    for image_file, label_file in zip(image_list, label_list):
        try:
            # 이미지 파일 이동
            shutil.copy(image_file, os.path.join(dest_image_folder, os.path.basename(image_file)))
            # 라벨 파일 이동
            shutil.copy(label_file, os.path.join(dest_label_folder, os.path.basename(label_file)))
        except Exception as e:
            print(f"파일 이동 실패: {image_file} 또는 {label_file} -> {e}")

# 클래스별로 파일을 처리하고 분할하는 함수
def split_and_move_files(category, num_sample):
    # 이미지와 라벨 경로 설정
    category_image_path = image_folders[category]
    category_label_path = label_folders[category]

    # 해당 폴더의 모든 이미지 파일과 라벨 파일을 리스트로 가져오기
    all_images = [os.path.join(category_image_path, f) for f in os.listdir(category_image_path) if f.endswith(tuple(image_ext))]
    all_labels = [os.path.join(category_label_path, f) for f in os.listdir(category_label_path) if f.endswith('.txt')]

    # 이미지와 라벨의 교집합(파일 이름이 동일한 경우만)
    image_basenames = set([os.path.splitext(os.path.basename(f))[0] for f in all_images])
    label_basenames = set([os.path.splitext(os.path.basename(f))[0] for f in all_labels])
    common_basenames = image_basenames.intersection(label_basenames)

    # 이미지와 라벨 교집합만 리스트로 필터링
    filtered_images = [os.path.join(category_image_path, f + '.jpg') for f in common_basenames if os.path.exists(os.path.join(category_image_path, f + '.jpg'))]
    filtered_labels = [os.path.join(category_label_path, f + '.txt') for f in common_basenames]

    # 데이터가 충분한지 확인
    if len(filtered_images) < num_sample or len(filtered_labels) < num_sample:
        print(f"{category} 폴더에 사용할 수 있는 데이터가 충분하지 않습니다. 최소 {num_sample}개 필요합니다.")
        return

    # 랜덤으로 num_sample 개수만큼 추출
    sampled_data = random.sample(list(zip(filtered_images, filtered_labels)), num_sample)
    sampled_images, sampled_labels = zip(*sampled_data)

    # 데이터셋 섞기
    combined = list(zip(sampled_images, sampled_labels))
    random.shuffle(combined)
    sampled_images, sampled_labels = zip(*combined)

    # 데이터셋 크기 계산
    total_size = len(sampled_images)
    train_size = int(train_ratio * total_size)

    # 데이터셋 분할 (train: 70%, val: 30%)
    train_images = sampled_images[:train_size]
    train_labels = sampled_labels[:train_size]
    val_images = sampled_images[train_size:]
    val_labels = sampled_labels[train_size:]

    # 파일 이동 실행 (train 및 val 폴더로 이동)
    move_files(train_images, train_labels, os.path.join(train_base_path, 'images', category), os.path.join(train_base_path, 'labels', category))
    move_files(val_images, val_labels, os.path.join(val_base_path, 'images', category), os.path.join(val_base_path, 'labels', category))

    print(f"{category} 데이터 분할 완료 - Train: {len(train_images)}개, Val: {len(val_images)}개")

# 각 카테고리별로 데이터셋 분할 및 파일 이동
for category in categories:
    split_and_move_files(category, num_samples[category])

print("데이터셋 클래스별 7:3 분할 완료!")

#매칭되지 않는것 확인
import os

# 이미지 및 라벨 폴더 경로 설정 (올바른 폴더 구조 반영)
image_folder_train_disease = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/train/images/disease'
label_folder_train_disease = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/train/labels/disease'

image_folder_train_normal = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/train/images/normal'
label_folder_train_normal = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/train/labels/normal'

image_folder_val_disease = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/val/images/disease'
label_folder_val_disease = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/val/labels/disease'

image_folder_val_normal = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/val/images/normal'
label_folder_val_normal = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/val/labels/normal'

# 이미지 확장자와 라벨 파일 확장자 설정
image_extension = '.jpg'
label_extension = '.txt'

# 이미지 파일과 라벨 파일을 비교하여 매칭되지 않는 파일을 출력하는 함수
def print_unmatched_files(image_folder, label_folder):
    # 이미지 파일 목록 (확장자 제외)
    image_files = set(os.path.splitext(f)[0] for f in os.listdir(image_folder) if f.endswith(image_extension))
    # 라벨 파일 목록 (.txt 확장자)
    label_files = set(os.path.splitext(f)[0] for f in os.listdir(label_folder) if f.endswith(label_extension))

    # 이미지에 대응하는 라벨 파일이 없는 경우
    unmatched_images = image_files - label_files
    # 라벨에 대응하는 이미지 파일이 없는 경우
    unmatched_labels = label_files - image_files

    # 매칭되지 않는 이미지 파일 출력 및 개수
    print(f"\n{image_folder}에서 매칭되지 않는 이미지 파일:")
    print(f"총 {len(unmatched_images)}개의 이미지 파일이 매칭되지 않습니다.")
    for image in unmatched_images:
        image_path = os.path.join(image_folder, image + image_extension)
        if os.path.exists(image_path):
            print(f"매칭되지 않는 이미지 파일: {image_path}")

    # 매칭되지 않는 라벨 파일 출력 및 개수
    print(f"\n{label_folder}에서 매칭되지 않는 라벨 파일:")
    print(f"총 {len(unmatched_labels)}개의 라벨 파일이 매칭되지 않습니다.")
    for label in unmatched_labels:
        label_path = os.path.join(label_folder, label + label_extension)
        if os.path.exists(label_path):
            print(f"매칭되지 않는 라벨 파일: {label_path}")

# 각 폴더에 대해 함수 실행 (확인만)
print_unmatched_files(image_folder_train_disease, label_folder_train_disease)
print_unmatched_files(image_folder_train_normal, label_folder_train_normal)
print_unmatched_files(image_folder_val_disease, label_folder_val_disease)
print_unmatched_files(image_folder_val_normal, label_folder_val_normal)

print("매칭되지 않는 파일들이 출력되었습니다.")

#yaml 생성
import yaml

# YAML 파일에 기록할 데이터 (경로 수정)
data = {
    'names': {
        0: 'Normal',
        1: 'Disease'
    },
    'train': [
        'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/train/images/normal',
        'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/train/images/disease'
    ],
    'val': [
        'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/val/images/normal',
        'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/val/images/disease'
    ]
}

# YAML 파일 저장 경로
yaml_file_path = r'C:/Users/school/PycharmProjects/Paper5_le/data_le.yaml'

# YAML 파일 생성 및 데이터 기록
with open(yaml_file_path, 'w') as file:
    yaml.dump(data, file, default_flow_style=False, sort_keys=False)

print(f"YAML 파일 생성 완료: {yaml_file_path}")

#YAML 참고
names:
  0: Normal
  1: Disease
train:
- C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/train/images/normal
- C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/train/images/disease
val:
- C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/val/images/normal
- C:/Users/school/PycharmProjects/Paper5_le/dataset_le_yolo_cls/val/images/disease

#학습 진행

#추론 (10개씩 사용하지 않은 이미지 경로에서 추출하여 추론), pt 는 경로 확인 필요
import os
import random
from ultralytics import YOLO
from PIL import Image
import matplotlib.pyplot as plt

# 학습된 모델 로드
model_path = r'C:/Users/school/PycharmProjects/run_finished/le/train4/weights/best.pt'
model = YOLO(model_path)

# 테스트할 이미지 경로 설정
image_folder_normal = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_ori/images/val/normal'
image_folder_disease = r'C:/Users/school/PycharmProjects/Paper5_le/dataset_le_ori/images/val/disease'

# 이미지 확장자 설정
image_extensions = ['.jpg', '.jpeg', '.png', '.JPG', '.JPEG']

# 각 폴더에서 랜덤으로 이미지 10개 선택
def get_random_images(image_folder, num_images=10):
    # 이미지 파일 목록 가져오기
    image_files = [os.path.join(image_folder, f) for f in os.listdir(image_folder) if f.endswith(tuple(image_extensions))]

    # 이미지가 num_images 이상일 경우에만 랜덤 추출
    if len(image_files) >= num_images:
        return random.sample(image_files, num_images)
    else:
        return image_files  # 이미지가 부족하면 전체 반환

# 이미지 추론 및 시각화 함수
def infer_and_display_images(image_paths, model):
    for image_path in image_paths:
        print(f"추론 중: {image_path}")

        # 모델을 사용하여 이미지에서 객체 탐지
        results = model.predict(source=image_path, show=False)  # show=False로 직접 결과 표시를 피함

        # 결과 이미지 시각화 및 PIL로 변환
        result_image = results[0].plot()  # 결과를 시각화하여 이미지로 저장
        result_image_pil = Image.fromarray(result_image)  # OpenCV 이미지 형식을 PIL 이미지 형식으로 변환

        # PIL을 사용하여 이미지 표시
        result_image_pil.show(title=f"Result: {os.path.basename(image_path)}")

        # Matplotlib을 사용하여 시각화 (옵션)
        plt.figure(figsize=(10, 10))
        plt.imshow(result_image_pil)
        plt.axis('off')  # 축 숨기기
        plt.title(f"Result: {os.path.basename(image_path)}")
        plt.show()

# 각 폴더에서 랜덤으로 10개씩 이미지 추출
random_images_normal = get_random_images(image_folder_normal, 10)
random_images_disease = get_random_images(image_folder_disease, 10)

# 추론 및 시각화
print("\nNormal 폴더에서 랜덤 추출된 이미지 추론:")
infer_and_display_images(random_images_normal, model)

print("\nDisease 폴더에서 랜덤 추출된 이미지 추론:")
infer_and_display_images(random_images_disease, model)

#실시간비디오추론

from ultralytics import YOLO
import cv2

# 학습된 모델 로드
model = YOLO('C:/Users/school/PycharmProjects/Paper2/runs/train29/weights/best.pt')

# 비디오 파일 또는 카메라 사용 (카메라는 0번 디바이스)
cap = cv2.VideoCapture(0)  # 'video.mp4' 또는 카메라 사용 시 0

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    # 모델을 사용하여 프레임에서 객체 탐지
    results = model.predict(source=frame, show=True)

    # 결과 화면에 출력
    cv2.imshow('YOLOv8 Inference', results[0].plot())

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()

#youtube 추론
pip install pytube

from ultralytics import YOLO
import cv2
from pytube import YouTube
import os

# YouTube 동영상을 다운로드하여 로컬에 저장하는 함수
def download_youtube_video(youtube_url, download_folder='videos'):
    yt = YouTube(youtube_url)
    stream = yt.streams.filter(file_extension='mp4', res="360p").first()  # 해상도를 설정하거나 첫 번째 mp4 형식 스트림 선택
    os.makedirs(download_folder, exist_ok=True)
    download_path = stream.download(download_folder)  # 동영상을 다운로드하여 지정 폴더에 저장
    return download_path

# YouTube 동영상 URL 설정
youtube_url = 'https://www.youtube.com/watch?v=your_youtube_video_id'  # 여기에 원하는 유튜브 링크를 입력

# 동영상 다운로드
video_path = download_youtube_video(youtube_url)

# 학습된 모델 로드 (YOLOv8 모델 경로 설정)
model = YOLO('C:/Users/school/PycharmProjects/Paper2/runs/train29/weights/best.pt')

# 다운로드된 YouTube 동영상으로 비디오 캡처 객체 생성
cap = cv2.VideoCapture(video_path)

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    # 모델을 사용하여 프레임에서 객체 탐지
    results = model.predict(source=frame, show=True)

    # 결과 화면에 출력
    cv2.imshow('YOLOv8 Inference', results[0].plot())

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()